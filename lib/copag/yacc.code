#
# parser/lib/yacc.code --
#
#	Code fragements for the YACC file <syntax>.y
#
# Copyright (c) 1993-1997 Olav Schettler
#
# See the file "license.terms" for information on usage and redistribution
# of this file, and for a DISCLAIMER OF ALL WARRANTIES.
#
# $Id: yacc.code,v 1.1 1995/10/25 20:09:25 olav Exp $
#--------------------------------------------------------------------------
# $Log: yacc.code,v $
# Revision 1.1  1995/10/25  20:09:25  olav
# 1
#
#

block banner SYNTAX
%{
/*
 * SYNTAX.y -- yacc input generated by cocos-R3
 * Copyright (c) 1993-1997 Olav Schettler
 *
 * email: olav@werbemittel.com
 */

#include <stdio.h>
#include <string.h>
#include <assert.h>
#include <setjmp.h>
#include <tcl.h>

#include "bind.h"

extern "C" {
void* malloc (int);
void free (void*);
}

#include "tree.h"
ParseTree* SYNTAXTree;

extern int SYNTAXlex();

%}
end_block

block token ASSOC LIST
%ASSOC LISTend_block

block crt_node SYNTAX TYPE LAST ADD_KIDS

	  { $$ = SYNTAXTree->root = new Node (SYNTAXTree, TYPE, $1, $LAST, LAST);
	  ADD_KIDS}end_block

block crt_nil_node SYNTAX

	  { $$ = SYNTAXTree->root = (Node*) 0; }end_block

block add_tag SYNTAX TAG

	  { $$ = SYNTAXTree->root = $1; 
	    $$->tag = Coc_strdup (TAG);
	  }end_block

block del_node IX
	    delete $IX;
end_block

block rst_offset SYNTAX
	    SYNTAXTree->file->ptr -= SYNTAXTree->file->offset - $1->start +1;
	    SYNTAXTree->file->offset = $1->start;
end_block

block invoke PARENT CHILD TYPE
	    ParseTree* currentTree = PARENTTree; // just in case

	    printf ("==> \"CHILD\"\n");
	    extern ParseTree* CHILDParseTree_create (ParseTree*, int);
	    ParseTree* pt = CHILDParseTree_create (PARENTTree, PARENTdebug);
	    printf ("<== \"PARENT\"\n");

	    $$ = PARENTTree->root = pt->root;
	    $$->type = TYPE;
	    PARENTTree = currentTree;
	    if (!pt->valid) {
		delete pt;
		PARENTTree->error ("child \"CHILD\" failed");
	    }
	  }
end_block

block opt SYNTAX TMP COMP
TMP
	: { $$ = SYNTAXTree->root = (Node*) 0; }
	| COMP
	;
end_block

block repeat SYNTAX TMP COMP
TMP
	: COMP
	  { $$ = SYNTAXTree->root = new Node (SYNTAXTree, -1, $1, $1, 2); 
	    $$->append ($1);
	  }
	| TMP COMP
	  { $$ = SYNTAXTree->root = $1;
	    $$->append ($2);
	  }
	;
end_block

block sep_repeat SYNTAX TMP COMP SEP
TMP
	: COMP
	  { $$ = SYNTAXTree->root = new Node (SYNTAXTree, -1, $1, $1, 2); 
	    $$->append ($1);
	  }
	| TMP SEP COMP
	  { $$ = $1;
	    $$->append ($3);
	  }
	;
end_block

block sep_list SYNTAX TMP2 TMP1 COMP SEP
TMP1
	: COMP 
	  { $$ = SYNTAXTree->root = new Node (SYNTAXTree, -1, $1, $1, 2); 
	    $$->append ($1);
	  }
	| TMP1 SEP COMP
	  { $$ = $1;
	    $$->append ($3);
	  }
	;
TMP2	: { $$ = SYNTAXTree->root = (Node*) 0; } 
	| TMP1
	;
end_block

block list SYNTAX TMP COMP
TMP
	: { $$ = SYNTAXTree->root = new Node (SYNTAXTree, -1, 0, 0, 2); }
	| TMP COMP
	  { $$ = $1;
	    $$->append ($2);
	  }
	;
end_block

block end_rules
%%

static char* NodeTypeName[] = {
end_block

block trailer_1
 "any"
};

struct Item {
  enum Type { nil_, id_, literal_, list_, repeat_, opt_ };
  Type type;
  char* tag;
  char* sep;
  char* text;
};

struct Rule {
  char* name;
  int type;
  int first;
  int last;
};

static Coc_EnumType* NodeType;
end_block

block trailer_2 SYNTAX SYM_CNT
  { 0, 0, 0 }
};

Tcl_HashTable SYNTAXRules;

static Node*
unparse (Coc_Info* info, Rule* rule, int parmCnt, Coc_Variable parm[])
{
  printf ("unparse: <%d: %s>\n", rule->type, rule->name);
  Node* result = new Node (rule->type, "", rule->last - rule->first);
  int ix, i;
  for (i = rule->first, ix = 0; i < rule->last; i++, ix++) {
	Item item = ItemTable [i];
	switch (item.type) {
	case Item::literal_:
		result->kid (ix, new Node (-2, item.text));
		break;
	default: {
		Node* kid;

		char* name;
		if (item.tag[0] != '\0') {
			name = item.tag;
		} else {
			name = item.text;
		} 
		// check if we got a matching command line argument
		Coc_Value* parmValue;
		if (parmValue = Coc_getParameter (info, name, parmCnt, parm, (Coc_TypeProc) Coc_stringType)) {
			// take command line parameter instead of rule text 
			char* tag = strtok (parmValue->sval, " \t");
			
			if (!tag) {
				Tcl_AppendResult (info->interp, "usage: <tag> <text>", (char*) 0);
				return (Node*) 0;
			}
			kid = Node::special (info->interp, tag, tag + strlen (tag) + 1, item.sep);
			if (!kid) {
				return (Node*) 0;
			}
		} else {
			if (item.type == Item::list_ || item.type == Item::opt_) {
				result->kid (ix, (Node*) 0);
				continue;
			} else if (item.type == Item::repeat_) {
				Tcl_ResetResult (info->interp);
				Tcl_AppendResult (info->interp, "\nrepeat of \"", name, "\" needs command line parameter", (char*) 0);
				return (Node*) 0;
			}
		}										
		if (item.type == Item::list_ || item.type == Item::repeat_) {
			if (kid->type != -1) {
				delete kid;
				Tcl_AppendResult (info->interp, "\n\"", name, "\" needs a list", (char*) 0);
				return (Node*) 0;
			}
			result->kid (ix, kid);
		} else {
			if (parmValue) {
				result->kid (ix, kid);
			} else {
				Tcl_HashEntry* hPtr;
				if (!(hPtr = Tcl_FindHashEntry (&SYNTAXRules, item.text))) {
					Tcl_AppendResult (info->interp, "no such rule \"", item.text, "\"", (char*) 0);
					return 0;
				}
				kid = unparse (info, (Rule*) Tcl_GetHashValue (hPtr), parmCnt, parm);
				if (!kid) {
					return (Node*) 0;
				}
				result->kid (ix, kid);
			}
		}
		break;
	}}
  }
  return result; 
}

extern "C" int
SYNTAXTree_unparse (Coc_Info* info, Coc_Value& result, int parmCnt, Coc_Variable parm[])
{ 
  Coc_Value* ruleName;
  if (!(ruleName = Coc_getParameter (info, "rule", parmCnt, parm, (Coc_TypeProc) Coc_stringType))) {
	Tcl_AppendResult (info->interp, "\nusage: <tree> unparse -rule <rule> ...", (char*) 0);
	return TCL_ERROR;
  }
  Tcl_HashEntry* hPtr;
  if (!(hPtr = Tcl_FindHashEntry (&SYNTAXRules, ruleName->sval))) {
	Tcl_AppendResult (info->interp, "\nno such rule \"", ruleName->sval, "\"", (char*) 0);
	return TCL_ERROR;
  }
  Rule* rule = (Rule*) Tcl_GetHashValue (hPtr);

  result.oval = unparse (info, rule, parmCnt, parm);
  if (!result.oval) {
	return TCL_ERROR;
  }
  return TCL_OK;
}

extern "C" int
SYNTAX_Init (Coc_Info* info) 
{
  printf ("SYNTAX!\n");
  NodeType = Coc_EnumType::create (info, "SYNTAXNodeType", SYM_CNT, NodeTypeName);

  Coc_TypeProc cocosProc;
  assert (TCL_OK == Coc_getType (info, "TreeNode", cocosProc, coc_Node));

  Tcl_InitHashTable (&SYNTAXRules, TCL_STRING_KEYS);

  int newObj;
  for (int i = 0; RuleTable [i].name; i++) {
	Tcl_HashEntry* hPtr;
	hPtr = Tcl_CreateHashEntry (&SYNTAXRules, RuleTable [i].name, &newObj);
	assert (newObj);
	Tcl_SetHashValue (hPtr, (char*) &RuleTable [i]);
  }
//  Coc_TypeProc cocosProc;
//  Coc_Type* treeType;
//  assert (TCL_OK == Coc_getType (info, "SYNTAXParseTree", cocosProc, treeType));
//
//  Coc_Procedure* unparseProc = treeType->addProcedure ("unparse", SYNTAXTree_unparse, -1, Coc_stringType, 0, 0);
end_block

block trailer_3 SYNTAX
  return TCL_OK;
}

ParseTree*
SYNTAXParseTree_create (Tcl_Interp* interp, char* name, int debug)
{
  SYNTAXdebug = debug;
  return new ParseTree (interp, name, SYNTAXTree, NodeType, SYNTAXparse);  
}

ParseTree*
SYNTAXParseTree_create (ParseTree* tree, int debug)
{
  SYNTAXdebug = debug;
  return new ParseTree (*tree, SYNTAXTree, NodeType, SYNTAXparse);
}

extern "C" int
new_SYNTAXParseTree (Coc_Info* info, Coc_Value& result, int parmCnt, Coc_Variable parm[])
{ 
  Coc_Value* fileName;
  Coc_Value* option;
  int debug = 0;
  int dump = 0;

  if (!(fileName = Coc_getParameter (info, "file", parmCnt, parm, Coc_stringType))) {
    result.oval = (void*) 0;
    return TCL_ERROR;
  }
  if ((option = Coc_getParameter (info, "debug", parmCnt, parm, Coc_intType))) {
	debug = option->ival;
  }
  if ((option = Coc_getParameter (info, "dump", parmCnt, parm, Coc_intType))) {
    dump = option->ival;
  }
  Tcl_ResetResult (info->interp);

  ParseTree* pt = SYNTAXParseTree_create (info->interp, fileName->sval, debug);
  if (!pt->valid) {
    result.oval = (void*) 0;
    return TCL_ERROR;
  } else { 
	result.oval = (void*) pt;
  }

  return TCL_OK;
}

#ifdef MAIN
int
main (int argc, char** argv)
{
  Tcl_Main (argc, argv, Tcl_AppInit);
  return 0;
}
#endif

end_block
